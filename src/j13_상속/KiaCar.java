package j13_상속;

public class KiaCar extends Car{
	
	public KiaCar() {
		super(); //해당 클래스의 상위 클래스의 호출 또한 부모가 먼저 즉, 상위클래스가 먼저 
		//생성되어 하기때문에 항상 위에 존재해야함.
		
		//this가 해당클래스를 호출하는 것.
		System.out.println("자식");
		
	}
	
//	public void test() {
//		KiaCar kc = this; //단 this는 자기 자신의 주소를 변수로 대입해 호출가능함.
//		
//	}
	
//	@Override
//	public int discountPrice(int percentage) {
//		return super.discountPrice(percentage);//부모의 클래스에서 해당 메소드를 호출해란 의미.
//	} 
	//오버라이드를 정의해주면  부모가 가진 메소드를 자식 클래스에 다시 정의해주는것 but 원래라면 하나의 클래스에 동일한 메소드
	//를 정의 할 수 없는데 현대차 클래스와 기아차 클래스에서 상속받은 Car class는 서로 다른 주소를 가지고 있기때문에 가능한것.
	// 재정의 동일한 메소드명을 쓰되 상속 받은 클래스를 끊어 버리고 자신의 클래스에서 다시 쓴다. 자식클래스에 부모클래스의 메소드
	//를 오버라이드 해주지 않으면 단순 부모클래스를 참조하여 씀.
	
	/*
	 * class는 기본적으로 자료형으로 형변환하여 확장이 가능한데 상위와 하위 클래스 간의 상속받는 형식이 형변환 업, 다운 캐
	 * 스팅과 똑같은 구조이다. 상위에서 하위 즉, 다운캐스팅때는 명시를 해줘야하며 하위에서 상위 클래스로 가면 생략이 가능하다.
	 * 
	 * 오버라이드 할때 매개변수가 달라도 되는가? 매개변수명은 변해도 상관없지만 메소드명, 자료형은 동일해야한다. 왜냐? 상속받아
	 * 자식클래스에서 '재정의'한다는게 오버라이드의 정의이기때문...
	 * 
	 * 오버라이드를 하는 이유
	 * 상속을 받았고 생성자(A a) a에다 b나 c를 넣으면 넣은 클래스를 사용하는데 상속받은 클래스에서 재정의를 하고난뒤 test에서 
	 * a.show()로 메소드를 생성했을때 생성자에 (A b)에 호출하면 해당 클래스 b가 호출된다. 그러므로 AClass의 메소드를 개발자
	 * 가 유동적으로 사용하기위하여 쓸 수 있기 때문이라고 보면된다.
	 * 
	 */
	
	
	
	
}
